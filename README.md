# Операционные системы
## Индивидуальное домашнее задание №2
### Вариант 27

### Шиверских Елизавета Анатольевна
##### группа БПИ225
###### Ожидаемая оценка: 8

Задание: У одной очень привлекательной студентки есть N поклонников. Традиционно в день
св. Валентина очень привлекательная студентка проводит романтический вечер с одним из поклонников. Счастливый избранник
заранее не известен. С утра очень привлекательная студентка получает N «валентинок» с различными вариантами романтического
вечера. Выбрав наиболее заманчивое предложение, студентка извещает счастливчика о своем согласии, а остальных — об отказе.

[![Typing SVG](https://readme-typing-svg.herokuapp.com?color=%2336BCF7&lines=Faculty+of+Computer+science+student)](https://git.io/typing-svg)

### Отчёт
#### PS: Пункты про расширение отчета не прописывались явно, тк это само собой разумеющееся


### 4-5 баллов

#### Представить сценарий решаемой задачи поясняющий, каким образом исходные сущности и их поведение отображаются в процессы и их взаимодействие
##### Введение:
Действие разворачивается в университете в преддверии Дня святого Валентина. В университете есть одна студентка, которая, по общему мнению, является очень привлекательной. У нее есть несколько поклонников из числа студентов, которые тайно влюблены в неё и мечтают провести романтический вечер в День святого Валентина.

##### Исходные сущности:

* Студентка: Центр внимания. Она является объектом внимания нескольких поклонников.
* Поклонники: Группа студентов, которые тайно влюблены в студентку и мечтают провести с ней романтический вечер.
##### Поведение:

* Поклонники отправляют свои "валентинки": Каждый из поклонников придумывает свой вариант романтического вечера и анонимно отправляет его объекту обожания в качестве "валентинки".
* Студентка выбирает одну из "валентинок": Утром в День святого Валентина она собирается выбрать одну из "валентинок" случайным образом. Студентка делает свой выбор и готовится сообщить поклоннику о своем решении.
* Студентка сообщает о выборе: После того, как она сделала свой выбор, она отправляет сообщение поклоннику, которого выбрала, чтобы пригласить его на романтический вечер. Студентка также отправляет отказные сообщения остальным поклонникам.
* Поклонники реагируют на решение: Каждый из поклонников получает ответ от студентки и реагирует соответственно. Тот, кого выбрала студентка, ощущает радость и соглашается на свидание, в то время как остальные разочарованы и печальны.
##### Процессы и их взаимодействие:

###### Процесс-студентка (Анна):
* Студентка производит выбор поклонника.
* Студентка отправляет сообщения поклонникам.
###### Процессы-поклонники:
* Каждый поклонник создает свой процесс.
* Поклонники ждут, пока студентка не сделает свой выбор.
* Каждый поклонник реагирует на решение студентки после получения сообщения.
  
##### Взаимодействие:
* Отправка "валентинок": Поклонники отправляют свои "валентинки" (создание процессов-поклонников).
* Выбор поклонника: Студентка делает свой выбор (работа с разделяемой памятью). Поклонники ждут ее решения (ожидание семафора).
* Реакция на решение студентки: Поклонники реагируют на сообщение от нее (сообщение через семафор).

##### Завершение: 
После того как студентка сделала свой выбор и поклонники получили ответы, сценарий завершается, и студентка с выбранным фанатом встречаются на романтическом вечере в День святого Валентина.

#### В зависимости от выбранной схемы решения программа может использовать обмен данными через общую или разделяемую память. Применение семафоров: Множество процессов взаимодействуют с использованием именованных POSIX семафоров. Обмен данными ведется через разделяемую память в стандарте POSIX.
Это условие выполнено.
Для запуска программы:
```
chmod +x 4-5.sh
./4-5.sh
```
Вывод программы:

#### Реализовать завершение программы в соответствии с условием задачи, а также предусмотреть корректное завершение по прерыванию с клавиатуры по соответствующему сигналу.
Это условие выполнено. При помощи соответствующего шортката можно прервать работу программы.


#### Разработана программа, осуществляющая взаимодействие между тремя дочерними процессами с использованием неименованных каналов.
Процессы и связи между ними, а также связи процессов с входными выходным файлами.
- Процесс работы программы выводится в консоль 
- Разработано консольное приложение, использующее неименованные каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает текстовые данные из заданного файла (input.txt)
и через неименованный канал передает их второму процессу;
• второй процесс осуществляет обработку данных в соответствии
с заданием и передает результат обработки через неименованный канал третьему процессу;
• третий процесс осуществляет вывод данных в заданный файл. (output.txt)
-  Для задания имен входного и выходного файлов используются аргументы командной строки.
чтобы скомпилировать программу 
` gcc 4.c `
чтобы запустить программу 
`./a.out input.txt output.txt`
- Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write
-  Размеры буферов для хранения вводимых данных и результатов
обработки должны быть не менее 5000 байт. Допускается работа
только с такими файлам, которые за одно заносятся в буфер за
одно чтение. То есть допускается работа с файлом ограниченного
размера. Это позволяет не накладывать дополнительных условий
на алгоритмы обработки данных.
- Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
- Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
Тесотовое покрытие и результаты программы

Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
4.c     | acbd    | dbca |        True | 
4.c     | SecondTest	   | tseTdnoceS |       True      |
4.c     | what	  | tahw |      True       |
4.c     | why	 | yhw |      True       |
4.с    | IwannaSleep	  | peelSannawI |     True        |

![img](/p1.png)

### Оценка 5

#### Имеется приложение, которое с помощию функции fork() создает дочерние процессы. Первый процесс через первый именнованный канал char* pipe_read_calc = "prc.fifo" отправляет данные второму. Второй их обрабатывает и через второй именнованный канал char* pipe_calc_write = "pcw.fifo отправляет третьему процессу. Третий процесс выводит результат в файл. Синхронизация производится за счет блокировки процесса методом read().

- Процесс работы программы выводится в консоль 
- Разработано консольное приложение, использующее именованные
каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает текстовые данные из заданного файла
и через именованный канал передает их второму процессу;
• второй процесс осуществляет обработку данных в соответствии
с заданием и передает результат обработки через именованный
канал третьему процессу;
• третий процесс осуществляет вывод данных в заданный файл.
-  Для задания имен входного и выходного файлов используются аргументы командной строки.
чтобы скомпилировать программу 
` gcc 5.c `
чтобы запустить программу 
`./a.out input.txt output.txt`
- Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write
-  Размеры буферов для хранения вводимых данных и результатов
обработки должны быть не менее 5000 байт. Допускается работа
только с такими файлам, которые за одно заносятся в буфер за
одно чтение. То есть допускается работа с файлом ограниченного
размера. Это позволяет не накладывать дополнительных условий
на алгоритмы обработки данных.
- Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
- Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
Тесотовое покрытие и результаты программы

Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
5.c     | acbd    | dbca |        True | 
5.c     | SecondTest	   | tseTdnoceS |       True      |
5.c     | what	  | tahw |      True       |
5.c     | why	 | yhw |      True       |
5.с    | IwannaSleep	  | peelSannawI |     True        |

![img](/p2.png)

### Оценка 6

#### Имеется приложение, которое с помощию функции fork() создает дочерние процессы. Первый процесс через первый неименнованный канал отправляет данные второму. Второй их обрабатывает и через второй неименнованный канал отправляет назад перврому процессу, который выводит результат в файл. Синхронизация производится за счет блокировки процесса методом read().

- Процесс работы программы выводится в консоль 
- Разработано консольное приложение, использующее неименованные каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает текстовые данные из заданного файла
и через неименованный канал передает их второму процессу;
• второй процесс осуществляет обработку данных в соответствии
с заданием и передает результат обработки через неименованный канал обратно первому процессу;
• первый процесс осуществляет вывод данных в заданный файл
-  Для задания имен входного и выходного файлов используются аргументы командной строки.
чтобы скомпилировать программу 
` gcc 6.c `
чтобы запустить программу 
`./a.out input.txt output.txt`
- Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write
-  Размеры буферов для хранения вводимых данных и результатов
обработки должны быть не менее 5000 байт. Допускается работа
только с такими файлам, которые за одно заносятся в буфер за
одно чтение. То есть допускается работа с файлом ограниченного
размера. Это позволяет не накладывать дополнительных условий
на алгоритмы обработки данных.
- Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
- Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
Тесотовое покрытие и результаты программы

Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
6.c     | acbd    | dbca |        True | 
6.c     | SecondTest	   | tseTdnoceS |       True      |
6.c     | what	  | tahw |      True       |
6.c     | why	 | yhw |      True       |
6.с    | IwannaSleep	  | peelSannawI |     True        |

![img](/p3.png)

### Оценка 7

#### Имеется приложение, которое с помощию функции fork() создает дочерние процессы. Первый процесс через первый именнованный канал char* pipe_read_calc = "prc.fifo" отправляет данные второму. Второй их обрабатывает и через второй именнованный канал char* pipe_calc_write = "pcw.fifo отправляет назад первому процессу, который выводит результат в файл. Синхронизация производится за счет блокировки процесса методом read().

- Процесс работы программы выводится в консоль 
- Разработано консольное приложение, использующее именованные
каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает текстовые данные из заданного файла
и через именованный канал передает их второму процессу;
• второй процесс осуществляет обработку данных в соответствии
с заданием и передает результат обработки через именованный
канал обратно первому процессу;
• первый процесс осуществляет вывод данных в заданный файл.
-  Для задания имен входного и выходного файлов используются аргументы командной строки.
чтобы скомпилировать программу 
` gcc 7.c `
чтобы запустить программу 
`./a.out input.txt output.txt`
- Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write
-  Размеры буферов для хранения вводимых данных и результатов
обработки должны быть не менее 5000 байт. Допускается работа
только с такими файлам, которые за одно заносятся в буфер за
одно чтение. То есть допускается работа с файлом ограниченного
размера. Это позволяет не накладывать дополнительных условий
на алгоритмы обработки данных.
- Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
- Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
Тесотовое покрытие и результаты программы

Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
7.c     | acbd    | dbca |        True | 
7.c     | SecondTest	   | tseTdnoceS |       True      |
7.c     | what	  | tahw |      True       |
7.c     | why	 | yhw |      True       |
7.с    | IwannaSleep	  | peelSannawI |     True        |

![img](/p4.png)

### Оценка 8

-  разработать программу, которая осуществляет взаимодействие между
двумя независимыми (неродственными) процессами с использованием именованных каналов
- Процесс работы программы выводится в консоль 
- Разработано консольное приложение, использующее именованные
каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает текстовые данные из заданного файла
и через именованный канал передает их второму процессу;
• второй процесс осуществляет обработку данных в соответствии
с заданием и передает результат обработки через именованный
канал обратно первому процессу;
• первый процесс осуществляет вывод данных в заданный файл.
-  Для задания имен входного и выходного файлов используются аргументы командной строки.
чтобы скомпилировать программу 
` gcc 8_1.c -o one`
` gcc 8_2.c -o two`
Необходимо открыть 2 окна терминала и соответсвенно в них запустить 2 независимых файла
чтобы запустить программу 
`./one input.txt output.txt`
` ./two `
- Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write
-  Размеры буферов для хранения вводимых данных и результатов
обработки должны быть не менее 5000 байт. Допускается работа
только с такими файлам, которые за одно заносятся в буфер за
одно чтение. То есть допускается работа с файлом ограниченного
размера. Это позволяет не накладывать дополнительных условий
на алгоритмы обработки данных.
- Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
- Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
Тесотовое покрытие и результаты программы

Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
8.c     | acbd    | dbca |        True | 
8.c     | SecondTest	   | tseTdnoceS |       True      |
8.c     | what	  | tahw |      True       |
8.c     | why	 | yhw |      True       |
8.с    | IwannaSleep	  | peelSannawI |     True        |

![img](/p5.png)

### Оценка 9

#### Так же имеется две программы, но размер буффера ограничен 200 байтами. Чтение происходит порциями, которые сразу отправляются в второй процесс, где обрабатываются и возвращаюся в первый, после чего сразу пишутся в выходной файл.

В дополнение к требованиям на предыдущую оценку разработать программу, которая осуществляет взаимодействие между
двумя независимыми процессами с использованием именованных каналов. Обмен данным ведется ограниченными порциями
текста
1. Представлена общая схема решаемой задачи. Достаточно показать
процессы и связи между ними, а также связи процессов с входным
и выходным файлами.
2. Разработано консольное приложение, использующее именованные
каналы, обеспечивающее взаимодействие по следующей схеме:
• первый процесс читает ограниченную порцию текстовых данных из заданного файла и через именованный канал передает
их второму процессу;
• второй процесс осуществляет обработку части данных в соответствии с заданием и при необходимости передает результат
обработки (если он при этом сформировался) через именованный канал обратно первому процессу или получает от него
следующую порцию;
• первый процесс осуществляет вывод результата в заданный
файл или сразу, или по частям в зависимости от условия задачи и размера буфера, используемого для пересылки данных.
3. Для задания имен входного и выходного файлов используются аргументы командной строки.
4. Ввод и вывод данных при работе с файлами осуществляется через
системные вызовы read и write.
5. Размеры буферов для хранения вводимых данных и результатов обработки должны быть не более 200 байт. Допускается работа только
с файлам произвольного размера. То есть необходимы циклическое
считывание файла, передача его фрагментов по каналам и (если
возможно) обработка. Обосновать увеличение размера буфера для
обработки файла во втором процессе, если обработка данных по
частям невозможна.
6. Представлен набор (не менее пяти) текстовых файлов, на которых
проводилось тестирование программы.
7. Для каждого из тестовых файлов представлен файл, полученный
в результате работы программы.
8. Результаты работы приведены в отчете.

